---
title: 21索引的数据结构
--- 

## 1. 为什么使用索引

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220227204532mysql.png)

假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220227204613mysql.png)

## 2. 索引及其优缺点

### 2.1 索引概述

MySQL官方对索引的定义为: **索引(Index)是帮助MySQL高效获取数据的数据结构 。**

索引的本质: 索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现**高级查找算法**

### 2.2 优点

(1)类似大学图书馆建书目索引，提高数据检索的效率，降低**数据库的i/o成本。

 (2)通过创建唯一索引，可以保证数据库表中每一行**数据的唯一性**

 (3)在实现数据的参考完整性方面，可以加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。

(4)在使用分组和排序子句进行数据查询时，可以显著**减少查询中分组和排序时间**，降低了CPU的消耗。

### 2.3 缺点

- (1)创建索引和维护索引要**耗费时间**，并 且随着数据量的增加，所耗费的时间也会增加。
- (2)索引需要占 **磁盘空间**，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间，**存储在磁盘上** ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 
- (3)虽然索引大大提高了查询速度，同时却会**降低表的更新速度**。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

> 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先州除表中的索引，然
> 后插入数据，插入完成后再创建索引。

## 3. InnoDB中索引的推演

### 3.1 索引之前的查找

先来看一个精确匹配的例子:

```sql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
```

**1在一个页中的查找 **
假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不后分为两种情况：

- 以主键为搜索条件
  可以在页目录中使用 **二分法**快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列作为搜索条件
因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应槽。这种情况下只能从**最小记录**开始**依次遍历**单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

**2在很多页中查找**

大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：
- 定位到记录所在的页.
- 从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录 所在的页，所以只能 **从第一个页**沿着**双向链表**一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 **超级耗时**的。如果一个表有一亿条记录 呢?此时**索引**应运而生。

### 3.2 设计索引

建一个表:

```sql
CREATE TABLE index_demo
(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY (c1)
) ROW_FORMAT = Compact;
```

这个新建的 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228201743mysql.png)

我们只在示意图里展示记录的这几个部分:

- record_type :记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。
- Next_record  :记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。
-  各个列的值：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 
- 其它信息:除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。

将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228202143mysql.png)

把一些记录放到页里的示意图就是:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228202218mysql.png)

#### **1. 一个简单的索引设计方案**

我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢?因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们**想快速定位到需要查找的记录在那些数据页**中该咋办?我们可以为快速定位记录所在的数据页而**建立一个目录**，建这个目录必须完成下边这些事:

- **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**

  假设：每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之
  后我们向 index_demo 表插入3条记录：

  ```sql
  insert into index_demo
  values (1, 4, 'u'),
         (3,9,'d'),
         (5,3,'y');
  ```

  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：

  ![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228205157mysql.png)

  从图中可以看出来，index_demo 表中的3条记录都被插入到了编号为 10 的数据页中了。此时我们再来插入一条记录：

  ```sql
  insert into index_demo
  values (4, 4, 'a');
  ```

  因为 页10 最多只能放3条记录，所以我们不得不再分配一个新页：

  ![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228205546mysql-index.png)

  注意，新分配的**数据页编号**可能并不是连续的。它们只是通过维护着上一个页和下一个页的编号而建立了**链表**关系。另外，页10中用户记录最大的主键值是 5，而页28中有一条记录的主键值是4，因为5＞4，所以这就不符合下一个数据页中用户记录的主键值必须于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次**记录移动**，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：

  ![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228205811mysql-index.png)

  这个过程表明了在对页中的记录进行增删改操作的过程中，我们心须通过一些诸如 记录移动的操作来始终保证这个状态一直成立：下—个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们称为**页分裂。**

  

- **给所有的页建立一个目录项。**

  由于数据页的编号可能是不连续的，所以在向index_demo表中插入许多条记录后，可能是这样的效果：

  ![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228210031mysql-index.png)

  因为这些 16KB 的页在物理存储上是**不连续**的，所以如果想从这么多页中根据主键值**快速定位菜些记录所在的页**，我们需要给它们做个 目录 ，每个页对应一个目录项，每个目录项包括下边两个部分：

  - 页的用户记录中最小的主键值，我们用 key 来表示。
  - 页号，我们用 page_no 表示。

  所以我们为上动几个页做好的目录就像该样子：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228202710mysql.png)

以**页28**为例，它对应**目录项2**，这个目录项中包含着该页的页号**28**以及该页中用户记录的最小主 键值**5**。我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键 值快速查找某条记录的功能了。比如:查找主键值为**20**的记录，具体查找过程分两步:

- 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中(因为 12 < 20 < 209 )，它对应的页是 页9 。
- 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为**索引**。

#### **2. InnoDB中的索引方案**

#### 1 迭代1次:目录项纪录的页

我们把前边使用到的目录项放到数据页中的样子就是这样:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228203134mysql.png)

从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 **目录项记录**和普通的**用户记录**的不同点:

- 目录项记录的 record_type 值是1，而 普通用户记录 的 record_type 值是0。
- 目录项记录只有**主键值和页的编号**两个列，而普通的用户记录的列是用户自己定义的，可能包含 **很多列**，另外还有InnoDB自己添加的隐藏列。
- 了解:记录头信息里还有一个叫 **min_rec_mask** 的属性，只有在存储  **目录项记录**的页中的主键值最小的 **目录项记录**的 值为 1 ，其他别的记录的 **min_rec_mask**值都是 0 。

相同点:两者用的是一样的数据页，都会为主键值生成 Page Directory (页目录)，从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度。

现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:

- 1. 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页就是页9。
- 2. 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。

#### 2 迭代2次:多个目录项纪录的页

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228203631mysql.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:

- 为存储该用户记录而新生成了 页31 。
- 因为原先存储目录项记录的 页30的容量已满 (我们前边假设只能存储4条目录项记录)，所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步 骤，以查找主键值为 20 的记录为例:

- 确定 目录项记录页

  我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。

- 通过目录项记录页 确定用户记录真实所在的页 。

  在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。

- 在真实存储用户记录的页中定位到具体的记录。

#### 3 迭代3次:目录项记录页的目录页

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228203958mysql.png)

如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220228204335mysql-index.png)

这个数据结构，它的名称是 B+树 。

#### 4 B+Tree

一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设:存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么:

- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
- 如果B+树有2层，最多能存放**1_000X1_00=10_000  条记录。
- 如果B+树有3层，最多能存放 **1_000X1_000X1_00=100_000_000**条记录。
- 如果B+树有4层，最多能存放 **1_000X1_000X1_000X1_00=100_000_000_000**条记录。

你的表里能存放 100000000000 条记录吗?所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们 通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页)，又 因为在每个页面内有所谓的 Page Directory (页目录)，所以在页面内也可以通过 二分法 实现快速 定位记录。

### 3.3 常见索引概念

索引按照物理实现方式，索引可以分为 2 种:聚簇(聚集)和非聚簇(非聚集)索引。我们也把非聚集索引称为二级索引或者辅助索引。

#### 1. 聚簇索引

聚簇索引并不是一种单独的数据类型，而是**一种数据存储方式** （所有的用户记录都存储在叶子节点）也就是所谓的**索引即数据，数据及索引** 

> 聚簇：表示数据行和相邻的键值聚簇的存储在一起



**特点:**

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义:

	- 页内 的记录是按照主键的大小顺序排成一个 单向链表
	- 各个存放**用户记录的页**也是根据页中用户记录的主键大小顺序排成一个 双向链表 。
	- 存放**目录项记录的页**分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个**双向链表**

2. B+树的 叶子节点 存储的是完整的用户记录。

​	 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)。

我们把具有这两种特性的B树称为**聚簇索列**， 所有完整的用户记录都存放在这个**聚簇索引**的叶子节点处。这种聚簇索引并不需要我们在MysQL语句中显式的使用 INDEX 语句去创建，IpnoDB 存储号l擎会 自动的为我们创建聚簇索引。

**优点:**

- 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快
- 聚簇索引对于主键的**排序查找**和**范围查找**速度非常快
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。

**缺点:**

- 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个 自增的ID列为主键
- 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新
- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据

**限制**

- 对于mysql数据库，目前只有Innodb数据引擎支持聚簇索引，而myisam不支持
- 由于数据物理存储排序方式只能有一种，所以每个mysql的**表只能有一个聚簇索引**。一般情况下就是该表的主键，
- 如果没有定义主键，Innodb会选择**非空的唯一索引**代替，若果没有这样的索引，Innodb会隐式的定义一个主键来所谓聚簇索引
- 为了充分利用聚簇索引的特性，所以innodb表的主键尽量**选用有序的顺序id**，不建议使用无序的id，入uuid，md5，hash，字符串等作为主键，无法保证数据的顺序增长

#### 2. 二级索引(辅助索引、非聚簇索引)

上边介绍的**聚族索引**只能在搜索条件是**主键值**时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到尾沿箱链表依次遍历记录一遍。
答案：我们可以**多建几棵B＋**树 ，不同的B+树中的数据采用不同的排序规则。比方说我们用c2 列的大小作为数据页、页中记录的排序规则，再建一棵B+树，效果如下图所示：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/02/20220301203434mysql.png)

**概念:回表** 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树!

问题:为什么我们还需要一次 回表 操作呢?直接把完整的用户记录放到叶子节点不OK吗?

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220301204531mysql.png)

**聚簇索引和非聚簇索引的一些区别**

- 1聚簇索引的**叶子结点**存储的就是我们的**数据记录**，非聚簇索引的叶子结点存储的书**数据的位置**，非聚簇索引不会影响数据表的物理存储顺序。
- 2一个表**只能有一个聚簇索引**，因为只能有一种排序存储方式，但可以有**多个非聚簇索引**，叶就是多个索引目录提供数据检索。
- 3.使用聚簇索引的时候，数据的**查询效率高**，但对数据进行插入，删除更新等操作，效率会比非聚簇索引底。

#### 3.联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义:

- 先把各个记录和页按照c2列进行排序。
- 在记录的c2列相同的情况下，采用c3列进行排序

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220301205324mysql.png)

如图：

- 每条**目录项记录**都是有c2，c3，页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2相同，则按照c3列的值进行排序。
- B+树**叶子节点**处的用户记录由c2，c3和主键c1列组成。

注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:

- 建立 联合索引 只会建立如上图一样的1棵B+树。
- 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。

### 3.4 InnoDB的B+树索引的注意事项

#### **1. 根页面位置万年不动**

我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B树的形成过程是这样的：

- 每当为某个表创建一个B+树索引(聚筷索号1不是人为创建的，默认就有）的时候，都会为这个索引创建一个根节点 页面。最开始表中没有数据的时候，每个B+树索引对应的 根节点 中既没有用户记录，也没有目录项记录。
- 随后向表中插入用户记录时，先把用户记录存储到这个**根节点**中。
- 当根节点中的可用**空问用完时**继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如**页a**中，然后对这个新页进行 **页分裂**的操作，得到另一个新页，比如 页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 页a 或者 页b中，而根节点便升级为存储目录项记录的页，

这个过程特别注意的是：—个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立索引，那么已的根节点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引!擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

**2. 内节点中目录项记录的唯一性**

我们知道B+树索号(的内节点中日录项记录的内容是 **索引列 + 页号**的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：

| c1   | c2   | c3   |
| ---- | ---- | ---- |
| 1    | 1    | 'u'  |
| 3    | 1    | 'd'  |
| 5    | 1    | 'y'  |
| 7    | 1    | 'a'  |

如果二级索引中目录项记录的内容只是**索引列 ＋页号**的搭配的话，那么为 c2列建立索引后的B+树应该长这样：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220301211042mysql-index.png)

如果我们想新插入一行记录，其中c1c2.c3的值分别是：9、1、’c’，那么在修改这个为c2列建立的二级索引对应的B+树时便碰到了个大题：由于 页3中存储的目录项记录是由**c2列 +页号**的值构成的，页3 中的两条目录项记录对应的c2列的值都是 1，而我们 新插入的这条记录 的c2列的值也是 1，那我们这条新插入的记录到底应该放到 页4中，还是应该放到页5中啊？答案是：对不起，懵了。

为了让新插入记录能找到自己在那个页里，我们需要保证在**B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的**。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引的列值
- 主键值
- 页号

也就是我们把 主键值 也添加到二级索引内节点中的目录项记录了，这样就能保证B+树每一层节点中各条目录项记录除页号这个宁段外是唯一的，所以我们为c2列建立二级索号后的示意图卖际上应该是这样子的：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220301211630mysql.png)

这样我们再插入记录 (9， 1,'c'）时，由于 页3中存储的目录项记录是由**c2列 +主键 ＋页号**的值构成的，可以先把新记录的**c2**列的信和**页3**中各目录项记录的**c2列**的值作比较，如果c2列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的c2列+主键 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到 页5中。

**3. 一个页面最少存储2条记录**
一个B+树只需要很少的层级就可以轻松存储数亿系记录，查询速度相当不错！这是因为日+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果-个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？所以 InnoDB的一个数据页至少可以存放两条记录。

## 4. MyISAM中的索引方案

**B树索引适用存储引擎如表所示:**

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --------------- | ------ | ------ | ------ |
| B-Tree索引      | Y      | Y      | Y      |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引;而Memory默认的索引是Hash索引。

MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是**数据记录的地址**。

### 4.2 MyISAM索引的原理

我们知道 InnoDB中索引即数据，也就是**聚簇索引**的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了，而**MyISAM**的索引方案虽然也使用树形结构，但是却**将索引和数据分开存储：**

- 将表中的记录**按照记录的插入顺序**单独存储在一个文件中，称之为**数据文件**。这个文件并不划分为若千个数据页，有多少记录就往这个文件中塞多小记录就成了。由于在插入数据的时候并**没有刻意按照主键大小排序**所以我们并不能在这此数据上使用二分法进行查找。
- 使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为**索引文件**的另一个文件中。MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是**主键值 ＋ 数据记录地址**的组合。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302200306mysql-index.png)

这里设表一共有三列，假设我们以col1为主键，上图是一个MyISAN表的主索引(Primary key)示意。可以看出MyISAM的素引文件仅仅保存数据记录的地址。在MyISAM中，主键索引和二级素引 (Secondary key）在结构上没有任何区别，只是主键索引1要求key是唯一的，而二级索引的key可以重复。如果我们在Col2 上建立一个二级索引，则此索引的结构如下图所示：



![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302200703mysql-index.png)

同样也是一棵B+Tree. data域保存数据记录的地址。因此，MyISAM中索引!检索的算法为：首先按照B+Tree搜索算
法搜索索引：如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

### 4.3 MyISAM 与 InnoDB对比

**MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别:**

- 1 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。
-  InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。
- InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。
- MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。
- InnoDB要求表 必须有主键 ( MyISAM可以没有 )。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。

**小结**

了解不同存储引擎的索引l实现方式对于正确使用和优化索引都非常有帮助。比如：

举例1：知道了innoDB的索引实现后，就很容易明白**为什么不建议使用过长的字段作为主键**因为所有二级索号/都引用主键索引，过长的主键索引会令二级索引变得过大。

举例2：用非单调的字段作为主键在InnoDB中不是个好主意，因为innoDB数据文件本县是一棵B+Tree， 非单调的
主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用**自增宇段作为主键则是一个很好的选择。**

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302201059mysql-index.png)

## 5. 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗:

- 空间上的代价

  每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 **16KB** 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。

- 时间上的代价

  每次对表中的数据进行 **增、删、该**操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 **从小到大的顺序排序**而组成了**双向链表**。不论是叶子节点中的记录，还 是内节点中的记录(也就是不论是用户记录还是目录项记录)都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些**记录移位 、 页面分裂 、 页面回收**等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。

## 6. MySQL数据结构选择的合理性

### 6.1 全表遍历

### 6.2 Hash结构

hash 本身是一个函数，又被称为散列函数，可以大幅提升检索数据的效率

Hash 算法是通过某种确定性的算法（比如 MD5、SHAI SHA2、SHA3） 将输入转变为输出。**相同的输入水远可以
得到相同的输出，**假设输入内容有微小偏差，在输出中通常会有不同的结果。

**加快查找速度的数据结构，常见的两种**

- ​	树：如平衡二叉树，查询、插入、修改、删除的平均时间复杂度都是O(log2n)
- 哈希。如hashMap 查询、插入、修改、删除的平均时间复杂度都是O（1）

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302202138mysql.png)

采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+树需要自顶向下依次查找，多次访问节点才能找到数据，中日需要多次 10 操作，**从效率來说 hash 比 B+ 对更快**

在哈希的方式下，一个元素K处于h(k)中，即利用哈希函数h，根据关键字x计算出槽的位置。函数h将关键字域映
射到哈希表T[0..m-1]的槽位上

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302202250mysql.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做**碰撞** ，在数据库中一般采用**链接法**来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示:

```java
// 全表查询
// 算法复杂度为 O(n) 
@Test
public void test1(){
    int[] arr = new int[100000];
    for(int i = 0;i < arr.length;i++){
        arr[i] = i + 1;
    }
    long start = System.currentTimeMillis();
    for(int j = 1; j<=100000;j++){
				int temp = j;
        for(int i = 0;i < arr.length;i++){
            if(temp == arr[i]){
break; }
} }
long end = System.currentTimeMillis(); 
  System.out.println("time: " + (end - start)); //time: 823
}
```



```java
// hash
//算法复杂度为 O(1) 
@Test
public void test2(){
    HashSet<Integer> set = new HashSet<>(100000);
    for(int i = 0;i < 100000;i++){
        set.add(i + 1);
    }
    long start = System.currentTimeMillis();
    for(int j = 1; j<=100000;j++) {
        int temp = j;
        boolean contains = set.contains(temp);
    }
long end = System.currentTimeMillis(); 
  System.out.println("time: " + (end - start)); //time: 5
}
```

Hash结构效率高，那为什么索引结构要设计成树型呢?

- 原因1：Hash 素号仅能满足 （=）（二）和N 查询。如果进行 范围查询，哈希型的索号，时间复杂度会退化为o(n);而树型的“有序”特性，依然能够保持0(1og2N) 的高效率。
- 原因2：Hash 索号1还有一个缺陷，数据的存储是 没有顺序的，在ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。1
- 原因3：对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。
- 原因4：对于等值查询来说，通常 Hash 索号1的效率更高，不过也存在一种情况，就是 素引列的重复值如果很多，效率就会降低。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索号1通常不会用到重复值多的列上，比如列为性别、年龄的情况等。Hash索引适用存储引擎如表所示：

hash索引使用的存储引擎

| 索引 / 存储引擎 | MyISAM | InnoDB | Memory |
| --------------- | ------ | ------ | ------ |
| B-Tree索引      | n      | n      | Y      |

**Hash索引的适用性**

Hash 索引存在着很多限制，相比之下在数据库中 B+树索引的使用面会更广，不过也有一些场景采用Hash 索引/效率更高，比如在键值型(Key-Value）数据库中，**Redis 存储的核心就是 Hash 表。**

MySQL中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的宁段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行**等值查询**时候，采用Hash 索号l是个不错的选择。
另外，InnoDB 本身不支持 Hash 索引，但是提供 **自适应 Hash 索引 (Adaptive Hash Index）**。什么情况下才会使用自适应 Hash 索号|呢？如果某个数据经常被访问，当满足一定条件的时候，就会待这个数据页的地址存放到Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 B+树也具备丁 Hash 索引的优点

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302204045mysql.png)

采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。

我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如

```sql
show variables like '%adaptive_hash_index';
```

### 6.3 二叉搜索树

如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。

1. 二叉搜索树的特点

- 一个节点只能有两个字节点，也就是一个节点度不能超过2
- 左子节点<本节点；右子节点>=本节点，比我大的向右，比我小的向左

2. 查找规则

我们先来看下最基础的二叉搜索树 (Binary Search Tree），搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为 key：
1. 如果 key 大于根节点，则在右子树中进行查找；
2. 如果 key 小于根节点，则在左子树中进行查找;

3. 如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。

举个例子，我们对数列 （34，22，89，5，23， 77， 91）创造出来的二分查找树如下图所示：O(log2n)

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302205054mysql-index.png)

但是存在特殊的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是（5, 22, 23, 34, 77, 89, 91)，创造出来的二分搜索树如下图所示：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302205232mysql-index.png)

上面第二棵树也属于二分查找村，但是性能上己经退化成了一条链表，查找数据的时同复杂度变成了 Q(n)。你能看出来第一个树的深度是 3， 也就是说最多只需了 次比较，就可以找到节点，而第二个树的深度是 了，最多需要7次比较才能找到节点。

为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量**降低树的高度** ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。

### 6.4 AVL树

为了解决上面二叉查找树退化成链表的门题，人们提出了**平衡二叉搜素树 (Balanced Binary Tree**，又称为AvL树（有别于AVL算法），已在二叉搜索树的基础上增加了约束，具有以下性质：

**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并旦左右两个子树都是一棵平衡二叉树。**
这里说一下，常见的平衡二 叉树有很多种，包括了 **平衡二叉搜树、红黑树、数堆、伸展树**。平衡二叉搜索树
是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属干平衡二叉搜索树，搜索时间复杂度就是 。(Iog2N)

数据查询的时间主要依赖于磁盘 10 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索材进行了改进，树的深度也是 0(1og2n)，当n比较大时，深度也是比较高的，比如下图的情况：

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302205843mysql-index.png)

**每访问一次节点就需要进行一次磁益 I/0 操作，**对于上面的树来说，我们需要进行 5次10操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/0 操作次数多，会影响整体数据查询的效率。

针对同样的数据，如果我们把二叉树改成 **M 叉树 (M>2**)呢?当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302210022mysql-index.png)

你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉数M 大的时候，M 又树的高度会远小于二叉树的高度(（M>2)。所以，我们需要把树从"瘦南“变“矮胖”

### 6.5 B-Tree

B树的英文是 Balance Tree， 也就是 **多路平衡查找树**。简写为B-Tree (注意横杠表示这两个单词连起来的意思，不
是减号)。它的高度远小于平衡二叉树的高度。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302210239mysql-index.png)

B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点
`M称为B树的阶`，每个磁盘块中包括了**关键字**和 **子节点的指针**。如果一个磁盘块中包括了 x个关键字，那么指针数就是x十。对于-
个100阶的B树来说，如果有3层的话最多可以存储约 100 万的索引数据。对于大量的索引(数据来说，买用B树的结构是非常适
合的，因为树的高度要远小于二叉树的高度

一个 M 阶的 B 树(M>2)有以下的特性:

- 根节点的儿子数的范围是 [2,M]。
- 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为[ceil(M/2), M]。
- 叶子节点包括 k-1 个关键字(叶子节点没有孩子)，k 的取值范围为 [ceil(M/2), M]。
- 假设中间节点节点的关键字为:Key[1], Key[2], ..., Key[k-1]，且关键字按照升序排序，即 Key[i]<Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为:P[1], P[2], ...,P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k]指向关键字大于 Key[k-1] 的子树。
- 所有叶子节点位于同一层。

上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为(8，12)，它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。

然后我们来看下如何用B树进行查找。假设我们想要查找的关键字是 9，那么步骤可以分为以下几步:

- 我们与根节点的关键字 (17，35)进行比较，9 小于 17 那么得到指针 P1;
- 按照指针 P1 找到磁盘块 2，关键字为(8，12)，因为 9 在 8 和 12 之间，所以我们得到指针 P2;
- 按照指针 P2 找到磁盘块 6，关键字为(9，10)，然后我们找到了关键字 9。

你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。  **B树相比平衡二叉树来说磁盘I/O操作要少**， 在数据查询中比平衡二叉树效率要高。所以  **只要树的高度足够低，io此时足够少，就可以提高查询性能**。

-  B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的白平衡。

- 关键宇集合分布在整棵树中，即叶子 节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束

- 其搜索性能等价于在天键宇全集内做一次二分查找。

再举例1:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302211032mysql-index.png)

### 6.6 B+Tree

B+树也是一种多路搜索树，基于 B 树做出了改进，主流的 DBMS 都支持 B+树的索引方式，比如MysQL。相比于B-Tree， B+Tree适合文件素引系统。

**MySQL官网说明:**

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302211525mysql-index.png)

**B+ 树和 B 树的差异:**

- 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。
- 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大(或最 小)。
- 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，**非 叶子节点既保存索引，也保存数据记录 **
- 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。

> B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然

下图就是一棵 B+树，阶数为 3，根节点中的关键字1、 18、35分别是子节点（1, 8, 14) 、(18， 24, 31）和（35， 41， 53）中的最小值。每一层戈节点的关键宇都会出现在下一层的子节点的关键宇中，因此在叶子节点中包括了所有的关键字信息并且每
一个叶子节点都有一个指向下一个节点的指针，这样就形成了链表

![比如，我们想要查找关键字 16， e+树会自顶向下逐层进行直找：
与根节点的关键字(1，18，35) 进行比较，1 在1和18之间，得到指针口I(指向磁盛块2）](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302212517mysql-index.png)

比如，我们想要查找关键字 16， B+树会自顶向下逐层进行直找：

- 与根节点的关键字(1，18，35) 进行比较，1 在1和18之间，得到指针PI(指向磁盘块2）

- 找到磁盘块2，关键字为（1，8，14），因为16大于14，所以得到指针P3（指向磁盘块7）
- 找到磁盘块7，关键宇为 （14，16，17），然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数据。



整个过程一共进行了3次10操作，看起来 B+树和已树的查询过程差不多，但是 B+树和B树有个根本的差异在于，**B+树的中间节点井不直接存储数据。**这样的好处都有什么呢？

- 首先，**B+树查询效率更稳定**因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。

- 其次，**B+树的查询效率更高。**这是因为通常 B+树比B树 **更矮胖** （阶数更大，深度更低），查询所需要的磁盘IO 也会更少。同样的磁盘页大小，B+树可以存储更多的节点关键字。
- 不仅是对单个关键宇的查询上，在查询范国上，B+树的效率也比 B树高。这是因为所有关键宁都出现在B+树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。



**为了减少IO，索引树会一次性加载吗?**

> 1.数据库秦号(是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。
> 2.当我们利用索引查询时候，是不可能将全部几个G的索号(都加载进内存的，我们能做的只能是：逐一加载
> 每一个磁盘页，因为磁盘页对应看索引树的节点。

**B+树的存储能力如何?为何说一般查找行记录，最多只需1~3次磁盘IO**

> InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个宁节）或BGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说个页（B+Tree 中的一个节点）中大概存储16KB/8B+8B)=1KB〈个键值（因为是估值，为方便计算，这里的K 取值为 10^3。 也就是说一个深度为了的B+Tree 索号可以维护 10^3X10^3X10^3=10 亿条记录。这里假定一个数据页也存储10^3条行记录数据了)实际情况中每个节点可能不能填充满，因此在数据库中 **B+Tree 的高度一般都在 2~4层**MySOL 的nnoDB 存储号!擎在设计时是将根节点常驻内存的，也就是说查找某一健值的行记录时最多只需要1-3次磁盘IO操作。

**为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引?**

> - 1B+树的磁盘读写代价更低
>   B+树的内部结点并没有指向关键宇具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结
>   点的关键字存放在同一盒块中，那么盘块所能容纳的关键宁数量也越多。一次性读入内存中的需要查找的关
>   键宇也就越多。相对来说10读写次数也就降低了。
> - 2B+树的查询效率更加稳定
>   由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键宁的索引。所以任何关键字的查找必
>   须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同， 导致每一个数据的查询效率相当。

**Hash 索引与 B+ 树索引的区别**

>1Hash 索引**不能进行范里查询**，而B+树可以。这是因为 Hash 秦引指向的数据是无序的，而已+树的叶子节
>点是个有序的链表。
>2hash 索引**不支持联合素引的最左侧原则**，(即联合索引的部分索引无法使用）而B+树可以。对于联合索引来说，Hash 索号在计算Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索/单独计算Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。
>3hash 索号不支特 ORDER BY 排序， 因为 Hash 素引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段 ORDER BX 排序优化的作用。同理，我们也无法用 Hash索引进行模糊查询而B+树使用 LIKE 进行模糊查询的时候，LIKE 后面后模糊查询 （比如 ％ 结尾）的话就可以起到优化作业
>
>4 Innodb 不支持哈希索引

**Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗?**

> ![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302215321mysql-index.png)

### 6.7 R树

R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子:查找20英里以内所有的餐厅。如果 没有R树你会怎么解决?一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。

|            | MyISAM | InnoDB | Memory |
| ---------- | ------ | ------ | ------ |
| R-Tree索引 | Y      | Y      | N      |

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220302215503mysql-index.png)