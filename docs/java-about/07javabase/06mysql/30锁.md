---
title: 30锁
--- 

事务的 隔离性 由这章讲述的 锁 来实现。

## 1. 概述

在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对 ，因此产生了 锁 。同时 锁机制 也为实现MySQL 的各个隔离级别提供了保证。 也是影响数据库  的一个重要因素。所以锁对数据库而 言显得尤其重要，也更加复杂。

## 2. MySQL并发事务访问相同记录

并发事务访问相同记录的情况大致可以划分为3种:

### 2.1 读-读情况

读-读 情况，即并发事务相继 读取相同的记录 。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。

### 2.2 写-写情况

写-写 情况，即并发事务相继对相同的记录做出改动。

在这种情况下会发生 脏写 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务 相继对一条记录做改动时，需要让它们 排队执行 ，这个排队的过程其实是通过 锁 来实现的。这个所谓 的锁其实是一个 内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进 行关联的

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220319165654.png)

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候 就会在内存中生成一个 锁结构 与之关联。比如，事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220319165731.png)

trx：锁结构是哪一个事物发生的

is_wating: 当前事物是否在等待



![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220319165757.png)

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220319165819.png)

**小结几种说法:**

- 不加锁
  - 意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。
- 获取锁成功，或者加锁成功
  - 意思就是在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务 可以继续执行操作。
- 获取锁失败，或者加锁失败，或者没有获取到锁
  - 意思就是在内存中生成了对应的  ，不过锁结构的  属性为 true ，也就是事务 需要等待，不可以继续执行操作。

### 2.3 读-写或写-读情况

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

各个数据库厂商对 SQL标准 的支持都可能不一样。比如MySQL在 REPEATABLE READ 隔离级别上就已经解决了 幻读 问题。

### 2.4 并发问题的解决方案

怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢?其实有两种可选的解决方案:

- 方案一:读操作利用多版本并发控制( MVCC ，下章讲解)，写操作进行 加锁 。

> 普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。
>
> - 在 READ COMMITTED 隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了 事务不可以读取到未提交的事务所做的更改 ，也就 是避免了脏读现象;
> - 在 REPEATABLE READ 隔离级别下，一个事务在执行过程中只有 第一次执行SELECT操作 才会 生成一个ReadView，之后的SELECT操作都 复用 这个ReadView，这样也就避免了不可重复读 和幻读的问题。

- 方案二:读、写操作都采用 加锁 的方式。

**小结对比发现:**

- 采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 。
- 采用 加锁 方式的话， 读-写 操作彼此需要 ，影响性能。

一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况 下，要求必须采用 加锁 的方式执行。下面就讲解下MySQL中不同类别的锁。



## 3. 锁的不同角度分类

###  3.1 从数据操作的类型划分:读锁、写锁

- 读锁 :也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。
- 写锁 :也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

**需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。**

### 3.2 从数据操作的粒度划分:表级锁、页级锁、行锁

**\1. 表锁(Table Lock)**

1 表级别的S锁、X锁

在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级 别的 S锁 或者 X锁 的。在对某个表执行一些诸如 ALTER TABLE 、 DROP TABLE 这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务 中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 元数据锁 (英文名: Metadata Locks ， 简称 MDL )结构来实现的。

一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说 崩 溃恢复 过程中用到。比如，在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取 InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写:

 不过尽量避免在使用InnoDB存储引擎的表上使用 LOCK TABLES 这样的手动锁表语句，它们并不会提供 什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的 行锁 ，关于 InnoDB表级别的 S锁 和 X锁 大家了解一下就可以了。

2 意向锁 (intention lock)

InnoDB 支持 多粒度锁(multiple granularity locking) ，它允许 行级锁 与 表级锁 共存，而意向锁就是其中的一种 表锁 。

- 意向共享锁(intention shared lock, IS):事务有意向对表中的某些行加共享锁(S锁)

  ```
   -- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
   SELECT column FROM table ... LOCK IN SHARE MODE;
  ```

  

- 意向排他锁(intention exclusive lock, IX):事务有意向对表中的某些行加排他锁(X锁)

  ```
   -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 
   SELECT column FROM table ... FOR UPDATE;
  ```

  

即:意向锁是由存储引擎 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行 。

**意向锁的并发性**

