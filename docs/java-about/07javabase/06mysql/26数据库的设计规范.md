---
title: 26数据库的设计规范
---

## 范式

### 范式简介

在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。 可以理解为，一张数据表的设计结构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。

### 范式都包括哪些

目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是: **第一范式(1NF)、第二范式 (2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF，又称完美 范式) 。**

数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求满足最低要求的范式是第一范式(INF)。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF)，其余范式以次类推。
一般来说，在关系型数据库设计中，最高也就遵循到 BCNF，普遍还是 3NF但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是 反规范化

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220312213030mysql.png)

### 3键和相关属性的概念

这里有两个表:

球员表(player) :球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号 

球队表(team) :球队编号 | 主教练 | 球队所在地

- 超键 :对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如(球员编号) (球员编号，姓名)(身份证号，年龄)等。
- 候选键 :就是最小的超键，对于球员表来说，候选键就是(球员编号)或者(身份证号)。
- 主键 :我们自己选定，也就是从候选键中选择一个，比如(球员编号)
- 外键 :球员表中的球队编号
- 主属性 、 非主属性 :在球员表中，主属性是(球员编号)(身份证号)，其他的属性(姓名)(年龄)(球队编号)都是非主属性。

### 4 第一范式(1st NF)

第一范式主要是确保数据表中每个字段的值必须具有 原子性，也就是说数据表中每个字段的值为 不可再次拆分的最小数据单元。

我们在设计某个字段的时候，对于字段x 来说，不能把字段X 拆分成字段x1和字段x2。事实上，任何的 DBMS都会满足第一范式的要求，不会将字段进行拆分。

**举例1:**

假设一家公司要存储员工的姓名和联系方式。它创建一个如下表:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220312213332mysql.png)

该表不符合 1NF ，因为规则说“表的每个属性必须具有原子(单个)值”，lisi和zhaoliu员工的 emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220312213418mysql.png)

### 5 第二范式(2nd NF)

第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有
非主健字段，都必须完全依赖主键，不能只依赖主键的一部分，**如果知道主键的所有属性的值，就可以检索到任
何元组（行）的任何属性的任何值。（要求中的主键，其实可以拓展替换为候选键）

**举例1:**

成绩表 (学号，课程号，成绩)关系中，(学号，课程号)可以决定成绩，但是学号不能决定成绩，课 程号也不能决定成绩，所以“(学号，课程号)→成绩”就是 完全依赖关系 。

**举例2:**

比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为(球员编号，比赛编号)，我们可以通过候选键(或主键)来决定如下的关系:

```
(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
```

但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系:

```
(球员编号) → (姓名，年龄)

(比赛编号) → (比赛时间, 比赛场地)
```

对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢?

- 数据冗余:如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。
- 插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没 法插入。
- 删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉。
- 更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。

为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220312214724.png)

这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。

> 1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只 表达一个意思。

### 6 第三范式(3rd NF)

第三范式是在第二范式的基础上，确保数据表中的每-一个非主键字段都和主键字段直接相关，也就是说，**要求数据表中的所有非主键字段不能依赖于其他非主键字段。**（即，不能存在非主属性 A 依赖于非主属性 B，非主属性日依赖于主键c的情况，即存在“A-B一C'的决定关系）通俗地讲，该规则的意思是所有 非主键属性之问不能有依赖关系，必须 相互独立：
这里的主键可以拓展为候选键。



**举例1:**

部门信息表 :每个部门有部门编号(dept_id)、部门名称、部门简介等信息。

员工信息表 :每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。

如果不存在部门信息表，则根据第三范式(3NF)也应该构建它，否则就会有大量的数据冗余。

>  符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括:“每个非键属性依赖于键，依赖于 整个键，并且除了键别无他物”。

## 4. BCNF(巴斯范式)

人们在 3NF 的基础上进行了改进，提出了巴斯范式 (BCNF) ，也叫做巴斯-科德范式 (Boyce-Codd Normal Form)。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库元余度更小。所以，称为是 修正的第三范式，或扩充的第三范式，BCNF不被称为第四范式。
若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范
式。
一般来说，一个数据库设计符合3NF或BCNF就可以了。

**1. 案例**

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220313204634mysql.png)

在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。

仓库名决定了管理员，管理员也决定了仓库名，同时(仓库名，物品名)的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键。

- 候选键 :是(管理员，物品名)和(仓库名，物品名)，然后我们从候选键中选择一个作为 主键 ，比 如(仓库名，物品名)。
- 主属性 :包含在任一候选键中的属性，也就是仓库名，管理员和物品名。
- 非主属性 :数量这个属性。

**2. 是否符合三范式**

如何判断一张表的范式呢?我们需要根据范式的等级，从低到高来进行判断。

首先，数据表每个属性都是原子性的，符合 1NF 的要求;

其次，数据表中非主属性”数量“都与候选键全部依赖，(仓库名，物品名)决定数量，(管理员，物品 名)决定数量。因此，数据表符合 2NF 的要求;

最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。

**3. 存在的问题**

既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢?我们来看下面的情况:

- 增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因 此会出现 插入异常 ;
- 如果仓库更换了管理员，我们就可能会 修改数据表中的多条记录 ;
- 如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。

你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。

**4. 问题解决**

首先我们需要确认造成异常的原因:主属性仓库名对于候选键(管理员，物品名)是部分依赖的关系，这样就有可能导致上面的异常情况。因此引入BCNF，**它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系 。**

- 如果在关系R中，U为主键，A属性是主键的一个属性，若存在A->Y，Y为主属性，则该关系不属于 BCNF。

根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样:

- 仓库表 :(仓库名，管理员)
- 库存表 :(仓库名，物品名，数量)

这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。

## 5第四范式

多值依赖的概念：

- 多值依赖 即属性之间的一对多关系，记为K一一A
- 函数依赖 事实上是单值依赖，所以不能表达属性值之间的一对多关系。
- 平凡的多值依赖：全集U=K+A，一个K可以对应于多个A，即K一一A。此时整个表就是一组一对多关系。
- 非平凡的多值依赖：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B互相独立，即
  K一一A,K一一B。整个表有多组一对多关系，且有：“—"部分是相同的属性集合，“多"部分是互相独立的属性集合。

第四范式即在满足巴斯-科德范式（BCNF) 的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表内的多对多关系删除）

**举例1: 职工表(职工编号，职工孩子姓名，职工选修课程)。**

在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。

如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如: 职工表一 (职工编 号，职工孩子姓名)， 职工表二 (职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四 范式。

## 6. 第五范式、域键范式

除了第四范式外，我们还有更高级的第五范式(又称完美范式)和域键范式(DKNF)。

在满足第四范式(4NF)的基础上，消除不是由候选键所蕴含的连接依赖。 如果关系模式R中的每一个连 接依赖均由R的候选键所隐含 ，则称此关系模式符合第五范式。

函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由 语义直接导出 ，而是在 关系连接运算 时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。

第五范式处理的是 ，这个范式基本 没有实际意义 ，因为无损连接很少出现，而且难以察 觉。而域键范式试图定义一个 ，该范式考虑所有的依赖和约束类型，但是实用价值也是最小 的，只存在理论研究中。

### 8. ER模型

**ER 模型中有三个要素，分别是实体、属性和关系。**

- 实体 ，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体;弱实体是指对另 一个实体有很强的依赖关系的实体。

- 属性 ，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。
- 关系 ，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用 菱形 来表示。

注意:实体和属性不容易区分。这里提供一个原则:我们要从系统整体的角度出发去看， 可以独立存在 的是实体，不可再分的是属性 。也就是说，属性不能包含其他属性。